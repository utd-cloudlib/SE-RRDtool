.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RRDs 3pm"
.TH RRDs 3pm "2014-09-29" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RRDs \- Access RRDtool as a shared module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use RRDs;
\&  RRDs::error
\&  RRDs::last ...
\&  RRDs::info ...
\&  RRDs::create ...
\&  RRDs::update ...
\&  RRDs::updatev ...
\&  RRDs::graph ...
\&  RRDs::fetch ...
\&  RRDs::tune ...
\&  RRDs::times(start, end)
\&  RRDs::dump ...
\&  RRDs::restore ...
\&  RRDs::xport ...
\&  RRDs::flushcached ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Calling Sequence"
.IX Subsection "Calling Sequence"
This module accesses RRDtool functionality directly from within Perl. The
arguments to the functions listed in the \s-1SYNOPSIS\s0 are explained in the regular
RRDtool documentation. The command line call
.PP
.Vb 1
\& rrdtool update mydemo.rrd \-\-template in:out N:12:13
.Ve
.PP
gets turned into
.PP
.Vb 1
\& RRDs::update ("mydemo.rrd", "\-\-template", "in:out", "N:12:13");
.Ve
.PP
Note that
.PP
.Vb 1
\& \-\-template=in:out
.Ve
.PP
is also valid.
.PP
The RRDs::times function takes two parameters:  a \*(L"start\*(R" and \*(L"end\*(R" time.
These should be specified in the \fBAT-STYLE \s-1TIME\s0 \s-1SPECIFICATION\s0\fR format
used by RRDtool.  See the \fBrrdfetch\fR documentation for a detailed
explanation on how to specify time.
.SS "Error Handling"
.IX Subsection "Error Handling"
The \s-1RRD\s0 functions will not abort your program even when they can not make
sense out of the arguments you fed them.
.PP
The function RRDs::error should be called to get the error status
after each function call. If RRDs::error does not return anything
then the previous function has completed its task successfully.
.PP
.Vb 4
\& use RRDs;
\& RRDs::update ("mydemo.rrd","N:12:13");
\& my $ERR=RRDs::error;
\& die "ERROR while updating mydemo.rrd: $ERR\en" if $ERR;
.Ve
.SS "Return Values"
.IX Subsection "Return Values"
The functions RRDs::last, RRDs::graph, RRDs::info, RRDs::fetch and RRDs::times
return their findings.
.PP
\&\fBRRDs::last\fR returns a single \s-1INTEGER\s0 representing the last update time.
.PP
.Vb 1
\& $lastupdate = RRDs::last ...
.Ve
.PP
\&\fBRRDs::graph\fR returns an \s-1ARRAY\s0 containing the x\-size and y\-size of the
created image and a pointer to an array with the results of the \s-1PRINT\s0 arguments.
.PP
.Vb 3
\& ($result_arr,$xsize,$ysize) = RRDs::graph ...
\& print "Imagesize: ${xsize}x${ysize}\en";
\& print "Averages: ", (join ", ", @$averages);
.Ve
.PP
\&\fBRRDs::info\fR returns a pointer to a hash. The keys of the hash
represent the property names of the \s-1RRD\s0 and the values of the hash are
the values of the properties.
.PP
.Vb 4
\& $hash = RRDs::info "example.rrd";
\& foreach my $key (keys %$hash){
\&   print "$key = $$hash{$key}\en";
\& }
.Ve
.PP
\&\fBRRDs::graphv\fR takes the same parameters as \fBRRDs::graph\fR but it returns a
pointer to hash. The hash returned contains meta information about the
graph. Like its size as well as the position of the graph area on the image.
When calling with and empty filename than the contents of the graph will be
returned in the hash as well (key 'image').
.PP
\&\fBRRDs::updatev\fR also returns a pointer to hash. The keys of the hash
are concatenated strings of a timestamp, \s-1RRA\s0 index, and data source name for
each consolidated data point (\s-1CDP\s0) written to disk as a result of the
current update call. The hash values are \s-1CDP\s0 values.
.PP
\&\fBRRDs::fetch\fR is the most complex of
the pack regarding return values. There are 4 values. Two normal
integers, a pointer to an array and a pointer to a array of pointers.
.PP
.Vb 10
\&  my ($start,$step,$names,$data) = RRDs::fetch ... 
\&  print "Start:       ", scalar localtime($start), " ($start)\en";
\&  print "Step size:   $step seconds\en";
\&  print "DS names:    ", join (", ", @$names)."\en";
\&  print "Data points: ", $#$data + 1, "\en";
\&  print "Data:\en";
\&  for my $line (@$data) {
\&    print "  ", scalar localtime($start), " ($start) ";
\&    $start += $step;
\&    for my $val (@$line) {
\&      printf "%12.1f ", $val;
\&    }
\&    print "\en";
\&  }
.Ve
.PP
\&\fBRRDs::xport\fR exposes the rrdxport functionality and returns data
with the following structure:
.PP
.Vb 1
\&  my ($start,$end,$step,$cols,$names,$data) = RRDs::xport ...
\&  
\&  # $start : timestamp
\&  # $end   : timestamp
\&  # $step  : seconds
\&  # $cols  : number of returned columns
\&  # $names : arrayref with the names of the columns
\&  # $data  : arrayref of arrayrefs with the data (first index is time, second is column)
.Ve
.PP
\&\fBRRDs::times\fR returns two integers which are the number of seconds since
epoch (1970\-01\-01) for the supplied \*(L"start\*(R" and \*(L"end\*(R" arguments, respectively.
.PP
See the examples directory for more ways to use this extension.
.SH "NOTE"
.IX Header "NOTE"
If you are manipulating the \s-1TZ\s0 variable you should also call the \s-1POSIX\s0
function \fItzset\fR\|(3) to initialize all internal state of the library for properly
operating in the timezone of your choice.
.PP
.Vb 3
\& use POSIX qw(tzset);
\& $ENV{TZ} = \*(AqCET\*(Aq;   
\& POSIX::tzset();
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Tobias Oetiker <tobi@oetiker.ch>
